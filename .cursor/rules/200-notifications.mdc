---
description: Notification and user feedback standards for Apex
globs: ["src/**/*.{ts,tsx}", "src/lib/toast.ts", "src/stores/*.ts"]
alwaysApply: true
---

# Apex Notification Rules

## Toast System (Sonner)

### Implementation
- **Always use** `apexToast` utility from `src/lib/toast.ts` for all notifications.
- **Never** import `toast` directly from `sonner` - use the wrapper for consistency.
- The `<Toaster />` component is configured in `MainLayout.tsx` with:
  - `theme="dark"`
  - `position="top-center"`
  - `expand={false}`

### Automatic Toasts for Mutations
- **MANDATORY**: Every TanStack Query mutation (Create, Update, Delete) MUST show a toast notification.
- **MANDATORY**: Every form submission MUST show a toast notification.
- Use `apexToast.promise()` for async operations (mutations, API calls).
- Use `apexToast.success()` or `apexToast.error()` for synchronous operations or when promise handling is done manually.

### Toast Message Standards

#### Success Messages
- **MUST** be minimalist and concise.
- **GOOD**: "Ride Saved", "Bike Added", "Profile Updated"
- **BAD**: "Your ride has been successfully saved to the database", "The bike was added to your garage successfully"

#### Error Messages
- **MUST** include actionable information when possible.
- **MUST** use user-friendly, non-technical language.
- **MUST** use `apexToast.error()` with a "Retry" action if the operation can be retried.
- **DO NOT** expose technical error details (error codes, stack traces, etc.) to users.
- Example: `apexToast.error("Failed to save ride", { action: { label: "Retry", onClick: handleRetry } })`
- **BAD**: "PGRST301: Permission denied" or "Error: Cannot read property 'id' of undefined"
- **GOOD**: "Failed to save ride. Please try again." or "Permission denied. Please contact support."

#### Promise Messages
- Loading message: Describe the action in progress (e.g., "Adding machine to garage...")
- Success message: Confirm completion (e.g., "Bike successfully added to your fleet.")
- Error message: Provide context (e.g., "Failed to add bike. Check your connection.")

### Visual Style
- **Background**: `#0A0A0A` (apex-black)
- **Success border**: `#3DBF6F` (apex-green)
- **Error border**: `#E35B5B` (apex-red)
- **Text color**: `#f5f5dc` (apex-white)
- **Font**: Inherit from theme (use `font-mono` for numbers/data in toast content)

## Persistent Notifications (Server-Synced)

### Notification Store
- **MUST** use `useNotifications` for server-backed notifications and sync.
- Store location: `src/stores/useNotificationStore.ts` (client cache only).
- Hook location: `src/hooks/useNotifications.ts`
- Notifications are stored in `public.notifications` and synced across devices.
- Use cases:
  - Maintenance warnings (service intervals)
  - Critical system alerts
  - Business logic warnings that persist across page navigation

### Business Logic Alerts
- **MANDATORY**: When a calculation triggers a warning (e.g., Odometer approaching service interval):
  1. Insert into `public.notifications` (server) when possible
  2. Show a toast notification using `apexToast`
  3. Display the alert in the UI via `useNotifications`

### Alert Structure
```typescript
interface NotificationRow {
  id: string;
  user_id: string;
  type: 'warning' | 'error' | 'info';
  title?: string | null;
  message: string;
  read_at?: string | null;
  dismissed_at?: string | null;
  created_at: string;
  bike_id?: string | null;
  schedule_id?: string | null;
  source?: string | null;
  dedupe_key?: string | null;
}
```

## Server-Side Notifications

### Source of Truth
- **MANDATORY**: Server is the source of truth for notifications and read/dismiss state.
- **NEVER** keep long-lived local-only alerts unless `VITE_SERVER_NOTIFICATIONS=false`.
- **ALWAYS** write to `public.notifications` for system alerts and maintenance due warnings.

### Delivery Configuration
- **MANDATORY**: Delivery settings live in `public.app_settings`.
- **REQUIRED KEYS**: `edge_function_url`, `edge_function_service_key`.
- **DO NOT** use `ALTER SYSTEM` or server GUCs for delivery configuration.

### FCM (HTTP v1)
- **MANDATORY**: Use FCM HTTP v1 with a service account JSON.
- **Edge Function Secret**: `FCM_SERVICE_ACCOUNT_JSON` (stringified JSON).
- **DO NOT** use legacy server keys.

### Delivery
- **Push Tokens** live in `public.push_tokens`.
- **Edge Function** `send-notification` delivers push via FCM.
- **Queue**: `public.notification_delivery_queue` is processed by cron job.

### Safety
- **DO NOT** include sensitive data in push payloads.
- **DO** include identifiers (`notificationId`, `type`) only.
- **DO** rely on RLS for all client reads/writes.

## Examples

### TanStack Query Mutation
```typescript
const createBike = useMutation({
  mutationFn: async (bikeData) => { /* ... */ },
  onSuccess: () => {
    apexToast.success('Bike Added');
    queryClient.invalidateQueries({ queryKey: ['bikes'] });
  },
  onError: (error) => {
    apexToast.error(error.message || 'Failed to add bike');
  },
});
```

### Form Submission with Promise
```typescript
const handleSubmit = async (data) => {
  apexToast.promise(
    submitForm(data),
    {
      loading: 'Saving...',
      success: 'Saved',
      error: 'Save failed',
    }
  );
};
```

### Business Logic Alert (Server-Synced)
```typescript
const { data: { user } } = await supabase.auth.getUser();
if (kmUntilService <= 500 && user) {
  await supabase.from('notifications').insert({
    user_id: user.id,
    type: 'warning',
    title: 'Service Due',
    message: `${bike.nick_name} service due in ${kmUntilService} km`,
    bike_id: bike.id,
    source: 'client',
  });
  apexToast.error(`Service due soon: ${bike.nick_name}`);
}
```

## Error Handling Guidelines

### When to Show Toasts vs Console Errors

#### Show Toast to User (User-Facing Errors)
- **Mutations** (Create, Update, Delete operations) - Always show toast
- **Form submissions** - Always show toast
- **User-initiated actions** that fail - Show toast
- **Critical system errors** that affect user workflow - Show toast
- **Network/API errors** that the user can retry - Show toast

#### Keep as Logger Only (Internal/Debugging)
- **Background checks** (e.g., maintenance checker) - Log only using `logger`, toast only for critical failures
- **Geolocation errors** during ride recording - Log only using `logger`, component can handle user feedback
- **Non-critical validation errors** - Log only using `logger`
- **Development/debugging information** - Always use `logger.debug()` or `logger.trace()`

### Error Message Transformation

When catching errors from APIs or libraries:
1. **Log the full error** using logger for debugging: `logger.error('Technical error:', error)`
2. **Transform to user-friendly message** for toast: `apexToast.error('User-friendly message')`

Example:
```typescript
import { logger } from '../lib/logger';

try {
  await deleteBike.mutateAsync(id);
} catch (error) {
  // Log technical details for debugging
  logger.error('Delete error:', error);
  // Show user-friendly message
  apexToast.error(
    error instanceof Error 
      ? error.message  // If already user-friendly
      : 'Failed to delete bike. Please try again.'
  );
}
```

### Confirmation Modals

- **MANDATORY**: Use `ConfirmModal` component for destructive actions (delete, remove, etc.)
- **NEVER** use `window.confirm()` - it breaks the design system
- **Location**: `src/components/ConfirmModal.tsx`
- **Variants**: `danger` (red), `warning` (green), `default` (green)

## Local Notifications (@capacitor/local-notifications)

### Implementation
- **MANDATORY**: Always use utility functions from `src/lib/notifications.ts` for local notifications.
- **NEVER** import `LocalNotifications` directly from `@capacitor/local-notifications` - use the wrapper for consistency.
- **Native Platforms Only**: Local notifications only work on iOS/Android. Functions automatically check `Capacitor.isNativePlatform()` and return early on web.
- **NOTE**: Local notifications are a fallback when server notifications are disabled via `VITE_SERVER_NOTIFICATIONS=false`.

### Permission Handling
- **MANDATORY**: Always request permissions before scheduling notifications.
- The `requestNotificationPermissions()` function handles permission checks automatically.
- If permissions are denied, log a warning but don't fail the operation (graceful degradation).

### Use Cases

#### Time-Based Notifications
- **When**: Scheduled when a service is completed (if `interval_months > 0`).
- **Function**: `scheduleMaintenanceNotification(scheduleId, partName, bikeName, notificationDate)`
- **Behavior**: 
  - Automatically cancels any existing notification for the same schedule
  - Schedules notification for `last_service_date + interval_months`
  - Notification ID is derived from schedule UUID (deterministic)
- **Example**: When user completes "Engine Oil" service, schedules notification 6 months later.

#### Distance-Based Notifications
- **When**: Triggered immediately when odometer exceeds service interval threshold.
- **Function**: `triggerDistanceBasedNotification(partName, bikeName)`
- **Behavior**:
  - Triggered in `useRideTracking.saveRide()` after odometer update
  - Checks if `current_odo >= (last_service_odo + interval_km)`
  - Uses random notification ID (immediate, not scheduled)
- **Example**: When ride is saved and odometer shows 5,500 km (500 km past 5,000 km interval), triggers "Chain Lube Due!" notification.

### Notification Structure
```typescript
{
  id: number, // Derived from schedule UUID or random for immediate
  title: `⚠️ ${partName} Due`,
  body: `${bikeName} - ${partName} service is due`,
  schedule?: { at: Date }, // Only for time-based
  sound: 'default',
  actionTypeId: 'MAINTENANCE_DUE',
  extra: {
    scheduleId: string,
    partName: string,
    bikeName: string,
    type: 'maintenance',
    immediate?: boolean, // Only for distance-based
  },
}
```

### Notification Lifecycle

#### Scheduling
- **Time-based**: Automatically scheduled when service is completed via `useMaintenanceSchedules.completeService()`
- **Distance-based**: Automatically triggered in `useRideTracking.saveRide()` after odometer update
- **Cancellation**: Old notifications are automatically cancelled when new service is completed

#### Cleanup
- Use `cancelMaintenanceNotification(scheduleId)` to cancel a specific schedule's notification
- Use `cancelAllMaintenanceNotifications()` to cancel all maintenance notifications (e.g., on logout)

### Error Handling
- **MANDATORY**: Always wrap notification calls in try-catch blocks
- **MANDATORY**: Log errors using `logger.error()` for debugging
- **MANDATORY**: Never throw errors - notifications are non-critical (graceful degradation)
- **Pattern**: If notification fails, log error but continue with the operation (service completion, ride save, etc.)

### Platform Detection
- **MANDATORY**: All notification functions check `Capacitor.isNativePlatform()` first
- **Web Platform**: Functions return early with debug log (no error thrown)
- **Native Platform**: Functions proceed with permission check and scheduling

### Examples

#### Time-Based (Service Completion)
```typescript
// In useMaintenanceSchedules.ts completeService mutation
await scheduleMaintenanceNotification(
  scheduleId,
  schedule.part_name,
  bikeName,
  notificationDate // last_service_date + interval_months
);
```

#### Distance-Based (Ride Save)
```typescript
// In useRideTracking.ts saveRide mutation
if (kmSinceService >= schedule.interval_km) {
  await triggerDistanceBasedNotification(
    schedule.part_name,
    bikeName
  );
}
```

### Best Practices

#### Do's ✅
- **DO**: Use utility functions from `src/lib/notifications.ts`
- **DO**: Handle permission denials gracefully (log warning, continue operation)
- **DO**: Cancel old notifications before scheduling new ones
- **DO**: Log all notification operations for debugging
- **DO**: Check platform before attempting notification operations
- **DO**: Use deterministic notification IDs for scheduled notifications (derived from schedule UUID)

#### Don'ts ❌
- **DON'T**: Import `LocalNotifications` directly - use utility functions
- **DON'T**: Throw errors if notification fails - use graceful degradation
- **DON'T**: Schedule notifications on web platform (check platform first)
- **DON'T**: Skip permission checks before scheduling
- **DON'T**: Use random IDs for scheduled notifications (use deterministic IDs from schedule UUID)
- **DON'T**: Block user operations if notifications fail

## Anti-Patterns

- ❌ **DON'T**: Use `toast` directly from `sonner`
- ❌ **DON'T**: Show verbose success messages
- ❌ **DON'T**: Skip toast notifications for mutations
- ❌ **DON'T**: Use different toast styling than apexToast provides
- ❌ **DON'T**: Show persistent alerts without adding to NotificationStore
- ❌ **DON'T**: Use `window.confirm()` - use `ConfirmModal` instead
- ❌ **DON'T**: Show technical error details to users (error codes, stack traces)
- ❌ **DON'T**: Show toasts for background/automated processes (unless critical failure)
- ❌ **DON'T**: Skip logger.error for debugging - always log technical details using logger
- ❌ **DON'T**: Use console.* directly - always use logger from src/lib/logger
- ❌ **DON'T**: Import `LocalNotifications` directly - use utility functions from `src/lib/notifications.ts`
- ❌ **DON'T**: Throw errors if local notifications fail - use graceful degradation
- ❌ **DON'T**: Schedule notifications without checking platform or permissions
